{"metadata": {"dbt_schema_version": "https://schemas.getdbt.com/dbt/run-results/v6.json", "dbt_version": "1.9.2", "generated_at": "2025-02-28T20:35:08.367546Z", "invocation_id": "3378e280-d41a-4dd6-bdab-f36a10b4ba4f", "env": {}}, "results": [{"status": "success", "timing": [{"name": "compile", "started_at": "2025-02-28T20:34:59.707285Z", "completed_at": "2025-02-28T20:34:59.713869Z"}, {"name": "execute", "started_at": "2025-02-28T20:34:59.713869Z", "completed_at": "2025-02-28T20:35:01.856741Z"}], "thread_id": "Thread-729 (worker)", "execution_time": 2.14945650100708, "adapter_response": {"_message": "SUCCESS 1", "code": "SUCCESS", "rows_affected": 1, "query_id": "01bab3b3-010c-85a2-000b-a04300046582"}, "message": "SUCCESS 1", "failures": null, "unique_id": "model.dbt_sandbox.active_pricing", "compiled": true, "compiled_code": "/*\n\tProvides lookup for current active pricing by product.\n*/\n\nselect\n\tprod_id as product_id\n\t, max(eff_date) as price_date\nfrom dim_pricing \nwhere eff_date <= '2025-08-08'\ngroup by product_id", "relation_name": "DIMS.PUBLIC.active_pricing", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-02-28T20:35:01.883665Z", "completed_at": "2025-02-28T20:35:01.918036Z"}, {"name": "execute", "started_at": "2025-02-28T20:35:01.918867Z", "completed_at": "2025-02-28T20:35:02.862380Z"}], "thread_id": "Thread-729 (worker)", "execution_time": 0.9901058673858643, "adapter_response": {"_message": "SUCCESS 1", "code": "SUCCESS", "rows_affected": 1, "query_id": "01bab3b3-010c-8631-000b-a04300043576"}, "message": "SUCCESS 1", "failures": null, "unique_id": "model.dbt_sandbox.last_gen", "compiled": true, "compiled_code": "\n\nselect\n\tcurrent_timestamp() as last_run_datetime\n\t, current_date() as last_run_date\n\t, '2025-08-08'::date as last_gen_date", "relation_name": "DIMS.PUBLIC.last_gen", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-02-28T20:35:02.981476Z", "completed_at": "2025-02-28T20:35:03.002902Z"}, {"name": "execute", "started_at": "2025-02-28T20:35:03.003953Z", "completed_at": "2025-02-28T20:35:07.664748Z"}], "thread_id": "Thread-729 (worker)", "execution_time": 4.683271884918213, "adapter_response": {"_message": "SUCCESS 26", "code": "SUCCESS", "rows_affected": 26, "query_id": "01bab3b3-010c-834d-000b-a04300049486"}, "message": "SUCCESS 26", "failures": null, "unique_id": "model.dbt_sandbox.orders", "compiled": true, "compiled_code": "/*\n    Append generated orders to existing orders table.\n*/\n\n\n\nwith  __dbt__cte__renewals_calc as (\n/*\n\tEstablish whether subscriptions eligible to renew will actually renew on the run date given.\n*/\n\nwith renew_eligible as (\nselect\n\to.account_id \n\t, o.product_id \n\t, o.end_date\n\t, sum(o.quantity) as active_quantity\nfrom orders as o\nwhere o.end_date <= dateadd('day', 59, '2025-08-08')\n\tand o.end_date >= '2025-08-08'\ngroup by o.account_id, o.product_id, o.end_date\n)\nselect \n\tr.account_id\n\t, r.product_id\n\t, r.end_date\n\t, r.active_quantity\n\t, r.end_date - to_date('2025-08-08') + 1 as days_to_expiry\n\t, p.renewal_prob as renewal_prob_curved\n\t, case\n\t\twhen o2.contract_id is null then true \n\t\telse false\n\t\tend as eligible_for_renewal\n\t, case\n\t\twhen eligible_for_renewal = false\n\t\t\tthen 0\n\t\twhen r.active_quantity <= 10\n\t\t\tthen 0.891 * renewal_prob_curved\n\t\twhen r.active_quantity > 25 \n\t\t\tthen 0.932 * renewal_prob_curved\n\t\telse\n\t\t\t((r.active_quantity - 9) / 15 * (0.932 - 0.891) + 0.891) * renewal_prob_curved\n\t\tend as act_renewal_prob\n\t, uniform(0::float, 100::float, random()) as random_seed\n\t, case\n\t\twhen random_seed <= act_renewal_prob\n\t\t\tthen true\n\t\telse\n\t\t\tfalse\n\t\tend as renewed_flag\nfrom renew_eligible as r\nleft join orders as o2\n\ton o2.account_id = r.account_id\n\t\tand o2.product_id = r.product_id\n\t\tand o2.start_date = r.end_date\nleft join input_renewal_curve as p\n\ton p.days_to_exp = days_to_expiry\nwhere renewed_flag = true\n),  __dbt__cte__renewals_updown as (\n/*\n\tEstablish whether or not a renewal will upsell or downsell.\n*/\n\nselect\n\tr.account_id \n\t, r.product_id \n\t, r.end_date \n\t, r.active_quantity \n\t, r.renewed_flag\n\t, uniform(0::float, 100::float, random()) as random_seed \n\t, case\n\t\twhen random_seed <= 12.5 then\n\t\t\ttrue\n\t\telse \n\t\t\tfalse\n\t\tend as upsell_at_ren\n\t, case\n\t\twhen upsell_at_ren = true then\n\t\t\tfalse\n\t\twhen active_quantity = 1 then\n\t\t\tfalse\n\t\twhen random_seed >= (100 - 10.0) then\n\t\t\ttrue\n\t\telse\n\t\t\tfalse\n\t\tend as downsell_at_ren\n\t, case \n\t\twhen upsell_at_ren = false and downsell_at_ren = false \n\t\t\tthen true \n\t\telse \n\t\t\tfalse \n\t\tend as flat_renewal\n\t, uniform(0::float, 100::float, random()) as random_seed2\nfrom __dbt__cte__renewals_calc as r\n),  __dbt__cte__renewal_orders as (\n/*\n\tFinalize renewal orders in the column format required.\n*/\n\nwith \ncurrent_price_date as (\n\tselect\n\t\tprod_id as product_id\n\t\t, max(eff_date) as price_date\n\tfrom dim_pricing \n\twhere eff_date <= '2025-08-08'\n\tgroup by product_id\n),\nup_merge as (\n\tselect \n\t\ta.quantity\n\t\t, a.ptype_id\n\t\t, a.up_running as upper_prob\n\t\t, zeroifnull(b.up_running) as lower_prob\n\tfrom up_at_ren_prob_curve as a\n\tleft join up_at_ren_prob_curve as b\n\t\ton a.quantity = (b.quantity + 1) and a.ptype_id = b.ptype_id\n),\ndown_merge as (\n\tselect \n\t\ta.quantity\n\t\t, a.ptype_id\n\t\t, a.down_running as upper_prob\n\t\t, zeroifnull(b.down_running) as lower_prob\n\tfrom down_at_ren_prob_curve as a\n\tleft join down_at_ren_prob_curve as b\n\t\ton a.quantity = (b.quantity + 1) and a.ptype_id = b.ptype_id\n)\nselect \n\tr.account_id\n\t, '2025-08-08' as contract_date\n\t, r.product_id\n\t, r.end_date as start_date\n\t, dateadd('year', 1, r.end_date) as end_date\n\t, r.active_quantity + \n\t\tcase\n\t\t\twhen upsell_at_ren = true then \n\t\t\t\tu.quantity\n\t\t\twhen downsell_at_ren = true then \n\t\t\t\tcase\n\t\t\t\t\twhen d.quantity >= r.active_quantity then \n\t\t\t\t\t\t1 - r.active_quantity\n\t\t\t\t\telse \n\t\t\t\t\t\td.quantity * -1\n\t\t\t\t\tend\n\t\t\twhen flat_renewal = true then \n\t\t\t\t0\n\t\t\tend as qty\n\t, qty * p.unit_price as contract_amount\nfrom __dbt__cte__renewals_updown as r\nleft join dim_products as pr \n\ton pr.product_id = r.product_id\nleft join up_merge as u\n\ton r.random_seed2 <= u.upper_prob and r.random_seed2 > u.lower_prob and u.ptype_id = pr.ptype_id\nleft join down_merge as d\n\ton r.random_seed2 <= d.upper_prob and r.random_seed2 > d.lower_prob and d.ptype_id = pr.ptype_id\nleft join current_price_date as cpd\n\ton cpd.product_id = r.product_id\nleft join dim_pricing as p\n\ton qty <= p.max_qty and qty >= p.min_qty and cpd.price_date = p.eff_date and r.product_id = p.prod_id\n),  __dbt__cte__addon_calc as (\n/*\n\tFind subscriptions that are eligible to addon, and then calculate whether or not they actually addon.\n*/\n\nwith active_subs as (\n\tselect\n\t\to.account_id\n\t\t, o.product_id\n\t\t, o.end_date\n\t\t, sum(o.quantity) as active_quantity\n\tfrom orders as o\n\twhere\n\t\to.end_date >= '2025-08-08'\n\t\tand o.start_date < '2025-08-08'\n\tgroup by\n\t\to.account_id\n\t\t, o.product_id \n\t\t, o.end_date\n),\neligible_to_addon as (\n\tselect \n\t\te.account_id\n\t\t, e.product_id\n\t\t, e.end_date\n\t\t, e.active_quantity\n\t\t, o2.contract_id\n\t\t, o2.start_date\n\t\t, case \n\t\t\twhen e.end_date = o2.start_date then\n\t\t\t\ttrue\n\t\t\telse \n\t\t\t\tfalse\n\t\t\tend as pending_renewal\n\t\t, case\n\t\t\twhen o2.start_date is not null and e.end_date <> o2.start_date then \n\t\t\t\ttrue \n\t\t\telse \n\t\t\t\tfalse \n\t\t\tend as pending_addon\n\tfrom active_subs as e\n\tleft join orders as o2\n\t\ton o2.account_id = e.account_id \n\t\tand o2.product_id = e.product_id \n\t\tand o2.start_date >= '2025-08-08'\n\twhere \n\t\t\tpending_renewal = false \n\t\tand pending_addon = false\n\t\tand e.end_date > '2025-08-08'\n)\nselect\n\te.account_id\n\t, e.product_id\n\t, e.end_date\n\t, e.active_quantity\n--\t, .2 as addon_daily_prob\n\t, uniform(0::float, 100::float, random()) as random_seed\n\t, case \n\t\twhen random_seed <= 0.05 then \n\t\t\ttrue \n\t\telse \n\t\t\tfalse\n\t\tend as addon_flag\n\t, uniform(0::float, 100::float, random()) as random_seed2\nfrom eligible_to_addon as e\nwhere addon_flag = true\n),  __dbt__cte__addon_orders as (\n/* \n\tCalculate actual addon quantity and prepare for union.\n*/\n\nwith qty_merge as (\n\tselect \n\t\ta.quantity as qty\n\t\t, a.ptype_id\n\t\t, a.up_running as upper_prob\n\t\t, zeroifnull(b.up_running) as lower_prob\n\tfrom addon_prob_curve as a\n\tleft join addon_prob_curve as b\n\t\ton a.quantity = (b.quantity + 1) and a.ptype_id = b.ptype_id\n),\ncurrent_price_date as (\n\tselect\n\t\tprod_id as product_id\n\t\t, max(eff_date) as price_date\n\tfrom dim_pricing \n\twhere eff_date <= '2025-08-08'\n\tgroup by product_id\n)\nselect \n\ta.account_id\n\t, a.product_id\n\t, '2025-08-08' as contract_date\n\t, '2025-08-08' as start_date\n\t, a.end_date\n\t, q.qty as addon_quantity\n\t, a.active_quantity + q.qty as pricing_quantity\n\t, round(p.unit_price * addon_quantity * datediff('day', start_date, a.end_date) / 365, 2) as contract_amount\nfrom __dbt__cte__addon_calc as a\nleft join dim_products as pr\n\ton pr.product_id = a.product_id\nleft join qty_merge as q\n\ton a.random_seed2 <= upper_prob and a.random_seed2 > lower_prob and q.ptype_id = pr.ptype_id\nleft join current_price_date as cpd\n\ton cpd.product_id = a.product_id\nleft join dim_pricing as p\n\ton pricing_quantity <= p.max_qty and pricing_quantity >= p.min_qty and cpd.price_date = p.eff_date and a.product_id = p.prod_id\n),  __dbt__cte__recapture_calc as (\n/*\n\tIdentify churned customers and calculate if they rejoin.\n*/\n\nwith last_end as (\nselect\n\to.account_id\n\t, o.product_id\n\t, max(o.end_date) as last_end\nfrom orders as o\ngroup by o.account_id, o.product_id\n)\nselect\n\tle.account_id\n\t, le.product_id\n\t, le.last_end\n\t, datediff('day', le.last_end, '2025-08-08') as days_since_exp\n\t, rp.recap_prob * 0.01 as act_recap_prob\n\t, uniform(0::float, 100::float, random()) as random_seed\n\t, case \n\t\twhen random_seed <= act_recap_prob then\n\t\t\ttrue\n\t\telse\n\t\t\tfalse\n\t\tend as recap_flag\n\t, uniform(0::float, 100::float, random()) as random_seed2\n\t, uniform(0::float, 100::float, random()) as random_seed3\nfrom last_end as le\nleft join recap_prob_curve as rp\n\ton days_since_exp <= rp.max_days\n\t\tand days_since_exp >= rp.min_days\nwhere le.last_end < '2025-08-08'\n\tand recap_flag = true\n),  __dbt__cte__recapture_orders as (\nwith qty_merge as (\n\tselect \n\t\ta.quantity as qty\n\t\t, a.ptype_id\n\t\t, a.running_total as upper_prob\n\t\t, zeroifnull(b.running_total) as lower_prob\n\tfrom recap_qty_prob_curve as a\n\tleft join recap_qty_prob_curve as b\n\t\ton a.quantity = (b.quantity + 1) and a.ptype_id = b.ptype_id\n),\ncurrent_price_date as (\n\tselect\n\t\tprod_id\n\t\t, max(eff_date) as price_date\n\tfrom dim_pricing \n\twhere eff_date <= '2025-08-08'\n\tgroup by prod_id\n),\ndays_out as (\n\tselect \n\t\ta.days_to_start\n\t\t, a.running_total as upper_prob\n\t\t, zeroifnull(b.running_total) as lower_prob\n\tfrom days_to_start_curve as a\n\tleft join days_to_start_curve as b\n\t\ton a.days_to_start = (b.days_to_start - 1)\n)\nselect \n\tr.account_id\n\t, r.product_id\n\t, q.qty as quantity\n\t, q.qty * p.unit_price as contract_amount\n\t, '2025-08-08' as contract_date\n\t, dateadd('day', do.days_to_start, contract_date)::date as start_date\n\t, dateadd('year', 1, start_date) as end_date\nfrom __dbt__cte__recapture_calc as r\nleft join dim_products as pr\n\ton pr.product_id = r.product_id\nleft join qty_merge as q\n\ton r.random_seed2 <= q.upper_prob and r.random_seed2 > q.lower_prob and q.ptype_id = pr.ptype_id\nleft join current_price_date as cpd\n\ton cpd.prod_id = r.product_id\nleft join dim_pricing as p\n\ton quantity <= p.max_qty and quantity >= p.min_qty and cpd.price_date = p.eff_date\nleft join days_out as do\n\ton r.random_seed3 <= do.upper_prob and r.random_seed3 > do.lower_prob\n),  __dbt__cte__new_calc as (\n/*\n\tFigure out which products will have a new customer added.\n*/\n\nwith launched_products as (\n\tselect \n\t\tp.product_id\n\t\t, datediff('month', p.intro_date, '2025-08-08') as months_since_launch\n\tfrom dim_products as p\n\twhere p.intro_date <= '2025-08-08'\n),\neligible_cust_prod as (\n\tselect distinct\n\t\tc.customer_id as last_cust_id\n\t\t, lp.product_id\n\t\t, row_number() over (order by uniform(0::float, 100::float, random()) desc) as cust_prod_index\n\tfrom dim_customers as c\n\tjoin launched_products as lp\n\tleft join orders as o\n\t\ton o.account_id = c.customer_id and lp.product_id = o.product_id\n\twhere o.contract_id is null\n),\ncust_prod_map as (\n\tselect\n\t\tproduct_id\n\t\t, min(cust_prod_index) as next_cust\n\tfrom eligible_cust_prod\n\tgroup by product_id\n)\nselect \n\tlp.product_id\n\t, n.new_logos_per_month / date_part('day', last_day('2025-08-08'::date)) * 100 as prob\n\t, case \n\t\twhen lp.months_since_launch > 12 then\n\t\t\t12\n\t\telse\n\t\t\tlp.months_since_launch\n\t\tend as months_fix\t\n\t, uniform(0::float, 100::float, random()) as random_seed\n\t, case \n\t\twhen random_seed <= prob then\n\t\t\ttrue\n\t\telse\n\t\t\tfalse\n\t\tend as new_flag\n\t, e.last_cust_id as customer_id\n\t, uniform(0::float, 100::float, random()) as random_seed2\n\t, uniform(0::float, 100::float, random()) as random_seed3\nfrom launched_products as lp\nleft join dim_products as p \n\ton lp.product_id = p.product_id\nleft join new_logos_curve as n \n\ton n.ptype_id = p.ptype_id and months_fix = n.months_since_launch\nleft join cust_prod_map as m\n\ton m.product_id = lp.product_id\nleft join eligible_cust_prod as e\n\ton e.cust_prod_index = m.next_cust\n-- where new_flag = true\n),  __dbt__cte__new_orders as (\nwith qty_merge as (\n\tselect \n\t\ta.quantity\n\t\t, a.ptype_id\n\t\t, a.running_total as upper_prob\n\t\t, zeroifnull(b.running_total) as lower_prob\n\tfrom new_qty_prob_curve as a\n\tleft join new_qty_prob_curve as b\n\t\ton a.quantity = (b.quantity + 1) and a.ptype_id = b.ptype_id\n),\ncurrent_price_date as (\n\tselect\n\t\tp.prod_id as product_id\n\t\t, max(eff_date) as price_date\n\tfrom dim_pricing as p\n\twhere eff_date <= '2025-08-08'\n\tgroup by p.prod_id\n),\ndays_out as (\n\tselect \n\t\ta.days_to_start\n\t\t, a.running_total as upper_prob\n\t\t, zeroifnull(b.running_total) as lower_prob\n\tfrom days_to_start_curve as a\n\tleft join days_to_start_curve as b\n\t\ton a.days_to_start = (b.days_to_start - 1)\n)\nselect\n\tn.customer_id as account_id\n\t, '2025-08-08' as contract_date\n\t, n.product_id\n\t, q.quantity as quantity\n\t, q.quantity * p.unit_price as contract_amount\n\t, dateadd('day', do.days_to_start, contract_date)::date as start_date\n\t, dateadd('year', 1, start_date) as end_date\nfrom __dbt__cte__new_calc as n\nleft join dim_products as pr\n\ton pr.product_id = n.product_id\nleft join qty_merge as q\n\ton n.random_seed2 <= q.upper_prob and n.random_seed2 > q.lower_prob and q.ptype_id = pr.ptype_id\nleft join current_price_date as cpd\n\ton cpd.product_id = n.product_id\nleft join dim_pricing as p\n\ton quantity <= p.max_qty and quantity >= p.min_qty and cpd.price_date = p.eff_date and n.product_id = cpd.product_id\nleft join days_out as do\n\ton n.random_seed3 <= do.upper_prob and n.random_seed3 > do.lower_prob\n), last_contract as (\n    select \n        case when max(contract_id) is null then 10001 else max(contract_id) end as last_contract\n    from orders\n),\nfull_orders as (\n    select\n        r.account_id,\n        r.contract_date,\n        r.contract_amount,\n        r.product_id,\n        r.qty as quantity,\n        r.start_date,\n        r.end_date \n    from __dbt__cte__renewal_orders as r\n\n    union\n\n    select\n        a.account_id,\n        a.contract_date,\n        a.contract_amount,\n        a.product_id,\n        a.addon_quantity as quantity,\n        a.start_date,\n        a.end_date \n    from __dbt__cte__addon_orders as a\n\n    union\n\n    select\n        rc.account_id,\n        rc.contract_date,\n        rc.contract_amount,\n        rc.product_id,\n        rc.quantity,\n        rc.start_date,\n        rc.end_date \n    from __dbt__cte__recapture_orders as rc\n\n    union\n\n    select\n        n.account_id,\n        n.contract_date,\n        n.contract_amount,\n        n.product_id,\n        n.quantity,\n        n.start_date,\n        n.end_date \n    from __dbt__cte__new_orders as n\n)\n\nselect\n    f.account_id,\n    row_number() over (order by uniform(0::float, 100::float, random()) desc) + lc.last_contract as contract_id,\n    f.contract_date,\n    coalesce(f.contract_amount, f.quantity * dp.unit_price) as contract_amount,\n    f.product_id,\n    f.quantity,\n    f.start_date,\n    f.end_date \nfrom full_orders as f\njoin last_contract as lc on 1=1\njoin dim_pricing as dp\n    on f.product_id = dp.prod_id", "relation_name": "DIMS.PUBLIC.orders", "batch_results": null}], "elapsed_time": 10.97224235534668, "args": {"state_modified_compare_more_unrendered_values": false, "require_explicit_package_overrides_for_builtin_materializations": true, "write_json": true, "exclude": [], "favor_state": false, "partial_parse_file_diff": true, "use_colors_file": true, "require_batched_execution_for_custom_microbatch_strategy": false, "defer": false, "introspect": true, "print": true, "log_path": "C:\\Users\\243127.SZuluaga\\dbt_sandbox\\dbt_sandbox\\logs", "show_resource_report": false, "log_format_file": "debug", "cache_selected_only": false, "indirect_selection": "eager", "select": [], "warn_error_options": {"include": [], "exclude": []}, "require_resource_names_without_spaces": false, "empty": false, "invocation_command": "dbt ", "profiles_dir": "C:\\Users\\243127.SZuluaga\\dbt_sandbox\\dbt_sandbox\\azdevops", "send_anonymous_usage_stats": true, "partial_parse": true, "populate_cache": true, "require_yaml_configuration_for_mf_time_spines": false, "quiet": false, "strict_mode": false, "which": "run", "project_dir": "C:\\Users\\243127.SZuluaga\\dbt_sandbox\\dbt_sandbox", "use_colors": true, "macro_debugging": false, "log_level_file": "debug", "require_nested_cumulative_type_params": false, "state_modified_compare_vars": false, "log_file_max_bytes": 10485760, "skip_nodes_if_on_run_start_fails": false, "static_parser": true, "version_check": true, "log_level": "info", "printer_width": 80, "source_freshness_run_project_hooks": false, "log_format": "default", "vars": {"gen_date": "2025-08-08", "base_renewal_prob": 0.891, "max_renewal_prob": 0.932}}}